/*
 * rlcrackzip - Zip password cracker.
 *
 * Copyright (C) 2012 Ryan Lothian and Marc Lehmann (see AUTHORS file).
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include <stdint.h>
#include <algorithm>

#include "crc32.h"
#include "zip_crack.h"
#include "optimization.h"


/*
 * Sample output: "[111122223333444455556666]"
 */
std::ostream& operator<<(std::ostream& output, const ZipStreamCipher&  zsc)
{
    output << "[" << std::hex;
    for (uint32_t i = 0; i < 3; i++) {
        output << zsc.key[i];
    }
    output << "]" << std::dec;

    return output;
}


ZipStreamCipher
ZipStreamCipher::initialState()
{
    ZipStreamCipher zsc;

    zsc.key[0] = 0x12345678U;
    zsc.key[1] = 0x23456789U;
    zsc.key[2] = 0x34567890U;

    return zsc;
}


void
ZipStreamCipher::advanceOneByte (uint8_t  pw_char)
{
    this->key[0] = crc32(this->key[0], pw_char);
    this->key[1] = (this->key[1] + (uint8_t)this->key[0]) * 134775813U + 1U;
    this->key[2] = crc32(this->key[2], this->key[1] >> 24);
}


/*
 * Convert state to a byte that can be xored with plaintext to get ciphertext (or vice-versa of course).
 */
uint8_t
ZipStreamCipher::getKeystreamByte () const
{
    uint16_t t = this->key[2] | 2;
    return (t * (t ^ 1)) >> 8;
}


/*
 * DecodeChecker
 *
 * Idea: have special cases for JPEG in case the 12-bytes are random?
 */
DecodeChecker::DecodeChecker (bool quadratic_residue_checks) : is_quadratic_residue(65536) {
    if (quadratic_residue_checks) {
        for (uint32_t b = 0; b < 65536; b++) {
            is_quadratic_residue[(b * b) % 65536] = true;
        }
    } else {
        for (uint32_t q = 0; q < 65536; q++) {
            is_quadratic_residue[q] = true;
        }
    }
}


float DecodeChecker::false_positive_rate () const {
    return 1.0f / 256.0f; // very high :(
}


bool DecodeChecker::check (const file_info_type&                         file,
                           const StaticVector<uint8_t, FILE_READ_SIZE>&  decode) const {

// Commenting out: these were true in days of old but in recent versions only the last
//                 byte is guaranteed to be predictible. Still, we could check the CRC
//                 although this is slow for large files.

/*    uint16_t w2 = (decode[3] << 8) + decode[2];
    // first 16-bit word we will ignore for now
    // second 16-bit word is always a quadratic residue
    if (!this->is_quadratic_residue[w2]) {
        return false;
    }
    // third 16-bit word we will ignore for now
    // fourth 16-bit word is always a quadratic residue
    uint16_t w4 = (decode[7] << 8) + decode[6];

    if (!this->is_quadratic_residue[w4]) {
        return false;
    }

    // fifth 16-bit word == (compressed_filesize + 2) ^ low word of crc 32
    uint16_t  w5 = (decode[9] << 8) + decode[8];
*/
/*    if (w5 != (uint16_t)((file.compressed_size + 2) ^ file.crc32)) {
        return false;
    } */

    // sixth 16-bit word == upper word of crc 32

    /* With recent versions of pkzip this is all that is know about the 12 bytes */
    if (decode[11] != file.crc32 >> 24) {
        return false;
    }

    // IDEA: could check the crc against the decoded file. This is slow on large files, but
    //       cuts down the keyspace a lot. Problem is that it's the decompressed CRC, not
    //       the compressed CRC so I'd need to find libraries for or implement myself a load of stuff :(
/*
    if (file.file_type == FILE_TYPE_ASCII) {
        for (uint32_t i = 12; i < decode.size(); i++) {
            if (decode[i] >= 128) {
                return false;
            }
        }
    }
*/
/*
    uint16_t  w6 = (decode[11] << 8) + decode[10];
    if (w6 != (uint16_t)(file.crc32 >> 16)) {
        return false;
    }
*/
    return true; // if all match, this is a possible password
}


/*
 * crack_zip_password
 *
 * For each password generated by 'generator', decode the first 12 bytes of each file and
 * pass the result to checker to determine whether the decode is plausible.
 */
void
crack_zip_password (const std::vector<file_info_type>  &files,
                    GeneratorInterface                 &generator,
                    DecodeCheckerInterface             &checker,
                    PasswordCollectorInterface         &pw_collector)
{
    /*
     * ZIP passwords are changed into a 96-bit key with the following algorithm:
     * k_0 = some fixed initial state
     * k_n = f(k_{n-1}, p_n}
     *
     * Rather than recalculate k_{strlen(pw)} for every password, we only need to
     * recalculate from the point at which pw is first different to the previous pw.
     */

    StaticVector<ZipStreamCipher, MAX_PW_LEN + 1>  key_stack;
    StaticVector<char, MAX_PW_LEN>                 password;
    StaticVector<uint8_t, FILE_READ_SIZE>          decoded_bytes;

    key_stack.push_back(ZipStreamCipher::initialState());

    while (LIKELY(!generator.isDone())) {

        uint32_t      i;
        generator.next(&password, &i);

        /* Restore key (i will be number of leading characters same as last password) */
        ZipStreamCipher zsc = key_stack[i];

        /* Remove keystack items for subsequent characters. */
        key_stack.resize(i + 1);

        /* For each remaining character in the password, update the key and save in stack. */
        for (; i < password.size(); i++) {
            zsc.advanceOneByte(password[i]);
            key_stack.push_back(zsc); /* save on stack */
        }

        /* For each file decode the first 12 bytes and check whether they look sensible.*/
        /* We assume that all files use the same password */
        bool all_ok_so_far = true;
        for (uint32_t file_id = 0; file_id < files.size() && all_ok_so_far; file_id++) {
            const file_info_type &file = files[file_id];
            ZipStreamCipher  perfile_zsc = zsc;

            decoded_bytes.clear();

            for (uint32_t j = 0; j < std::min<uint32_t>(file.d.size(), decoded_bytes.capacity()); j++) {
                uint8_t decoded_byte   = file.d[j] ^ perfile_zsc.getKeystreamByte();
                perfile_zsc.advanceOneByte(decoded_byte);
                decoded_bytes.push_back(decoded_byte);
            }

            all_ok_so_far = checker.check(file, decoded_bytes);
        }
        if (all_ok_so_far) {
            pw_collector.collect(password);
        }
    }
}


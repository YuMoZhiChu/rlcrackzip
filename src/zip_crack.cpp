/*
 * rlcrackzip - Zip password cracker.
 *
 * Copyright (C) 2012 Ryan Lothian and Marc Lehmann (see AUTHORS file).
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include <stdint.h>
#include <algorithm>

#include "crc32.h"
#include "zip_crack.h"
#include "optimization.h"


/*
 * State of the zip stream cipher.
 */
typedef struct {
    uint32_t  key[3];
} zipkey_type;


inline zipkey_type
zipkey_get_initial_state ()
{
    zipkey_type zk;
    zk.key[0] = 0x12345678U;
    zk.key[1] = 0x23456789U;
    zk.key[2] = 0x34567890U;
    return zk;
}


/*
 * Advance stream cipher state by one byte. Note that the next state depends on the most
 * recent plaintext (or password) character.
 */
inline void
zipkey_step (zipkey_type   *zk,
             const uint8_t  pw_char)
{
    zk->key[0] = crc32(zk->key[0], pw_char);
    zk->key[1] = (zk->key[1] + (uint8_t)zk->key[0]) * 134775813U + 1U;
    zk->key[2] = crc32(zk->key[2], zk->key[1] >> 24);
}


/*
 * Convert state to a byte that can be xored with plaintext to get ciphertext (or vice-versa of course).
 */
inline uint8_t
zipkey_get_keystream_byte (const zipkey_type &zk)
{
    uint16_t t = zk.key[2] | 2;
    return (t * (t ^ 1)) >> 8;
}


/*
 * DecodeChecker
 *
 * Idea: have special cases for JPEG in case the 12-bytes are random?
 */
DecodeChecker::DecodeChecker (bool quadratic_residue_checks) : is_quadratic_residue(65536) {
    if (quadratic_residue_checks) {
        for (uint32_t b = 0; b < 65536; b++) {
            is_quadratic_residue[(b * b) % 65536] = true;
        }
    } else {
        for (uint32_t q = 0; q < 65536; q++) {
            is_quadratic_residue[q] = true;
        }
    }
}

// approx 1 in 100 billion passwords
float DecodeChecker::false_positive_rate () const {
    // 6.0f comes from fact that roughly a sixth are quadratic residues
    return 1.0f / (6.0f * 6.0f * 65536.0f * 65536.0f);
}


bool DecodeChecker::check (const file_info_type&                         file,
                           const StaticVector<uint8_t, FILE_READ_SIZE>&  decode) const {

/*    uint16_t w2 = (decode[3] << 8) + decode[2];
    // first 16-bit word we will ignore for now
    // second 16-bit word is always a quadratic residue
    if (!this->is_quadratic_residue[w2]) {
        return false;
    }
    // third 16-bit word we will ignore for now
    // fourth 16-bit word is always a quadratic residue
    uint16_t w4 = (decode[7] << 8) + decode[6];

    if (!this->is_quadratic_residue[w4]) {
        return false;
    }

    // fifth 16-bit word == (compressed_filesize + 2) ^ low word of crc 32
    uint16_t  w5 = (decode[9] << 8) + decode[8];
*/
/*    if (w5 != (uint16_t)((file.compressed_size + 2) ^ file.crc32)) {
        return false;
    } */

    // sixth 16-bit word == upper word of crc 32

    /* With recent versions of pkzip this is all that is know about the 12 bytes */
    if (decode[11] != file.crc32 >> 24) {
        return false;
    }

    // IDEA: could check the crc against the decoded file. This is slow on large files, but
    //       cuts down the keyspace a lot. Problem is that it's the decompressed CRC, not
    //       the compressed CRC so I'd need to find libraries for or implement myself a load of stuff :(
/*
    if (file.file_type == FILE_TYPE_ASCII) {
        for (uint32_t i = 12; i < decode.size(); i++) {
            if (decode[i] >= 128) {
                return false;
            }
        }
    }
*/
/*
    uint16_t  w6 = (decode[11] << 8) + decode[10];
    if (w6 != (uint16_t)(file.crc32 >> 16)) {
        return false;
    }
*/
    return true; // if all match, this is a possible password
}


/*
 * crack_zip_password
 *
 * For each password generated by 'generator', decode the first 12 bytes of each file and
 * pass the result to checker to determine whether the decode is plausible.
 */
void
crack_zip_password (const std::vector<file_info_type>  &files,
                    GeneratorInterface                 &generator,
                    DecodeCheckerInterface             &checker,
                    PasswordCollectorInterface         &pw_collector)
{
    /*
     * ZIP passwords are changed into a 96-bit key with the following algorithm:
     * k_0 = some fixed initial state
     * k_n = f(k_{n-1}, p_n}
     *
     * Rather than recalculate k_{strlen(pw)} for every password, we only need to
     * recalculate from the point at which pw is first different to the previous pw.
     */

    StaticVector<zipkey_type, MAX_PW_LEN + 1>  key_stack;
    StaticVector<char, MAX_PW_LEN>             password;
    StaticVector<uint8_t, FILE_READ_SIZE>      decoded_bytes;

    key_stack.push_back(zipkey_get_initial_state());

    while (LIKELY(!generator.isDone())) {

        uint32_t      i;
        generator.next(&password, &i);

        /* Restore key (i will be number of leading characters same as last password) */
        zipkey_type key = key_stack[i];

        /* Remove keystack items for subsequent characters. */
        key_stack.resize(i + 1);

        /* For each remaining character in the password, update the key and save in stack. */
        for (; i < password.size(); i++) {
            zipkey_step(&key, password[i]);
            key_stack.push_back(key); /* save on stack */
        }

        /* For each file decode the first 12 bytes and check whether they look sensible.*/
        /* We assume that all files use the same password */
        bool all_ok_so_far = true;
        for (uint32_t file_id = 0; file_id < files.size() && all_ok_so_far; file_id++) {
            const file_info_type &file = files[file_id];
            zipkey_type  perfile_key = key;

            decoded_bytes.clear();

            for (uint32_t j = 0; j < std::min<uint32_t>(file.d.size(), decoded_bytes.capacity()); j++) {
                uint8_t keystream_byte = zipkey_get_keystream_byte(perfile_key);
                uint8_t decoded_byte   = file.d[j] ^ keystream_byte;
                zipkey_step(&perfile_key, decoded_byte);

                decoded_bytes.push_back(decoded_byte);
            }

            all_ok_so_far = checker.check(file, decoded_bytes);
        }
        if (all_ok_so_far) {
            pw_collector.collect(password);
        }
    }
}

